fight() {
  let factoryDamages = [];
  let ammoConsumed = {};

  for (const factoryUnit of this.factoryUnits) {
    if (factoryUnit.attack > 0) {
      // Choose the first ammunition type with at least 1 ammunition left
      const selectedAmmo = ammunitionTypes.find(ammoType => this.ammunition[ammoType.name] && this.ammunition[ammoType.name] >= factoryUnit.consumesAmmo);

      if (selectedAmmo && this.ammunition[selectedAmmo.name] >= factoryUnit.consumesAmmo) {
        const totalDamage = factoryUnit.attack + selectedAmmo.damage;
        factoryDamages.push({ damage: totalDamage, ammo: selectedAmmo });
        this.ammunition[selectedAmmo.name] -= factoryUnit.consumesAmmo;
        ammoConsumed[selectedAmmo.name] = (ammoConsumed[selectedAmmo.name] || 0) + factoryUnit.consumesAmmo;
      }
    }
  }

  let biterDamages = [];
  for (const biterUnit of this.biterUnits) {
    biterDamages.push({ damage: biterUnit.attack, ammo: ammunitionTypes[0] });
  }

  this.attackUnits("Biters",this.biterUnits, this.factoryUnits, biterDamages);
  this.attackUnits("Factory",this.factoryUnits, this.biterUnits, factoryDamages);

}

const ammunitionTypes = [
  new Ammunition("Melee", 0,0,false),
  new Ammunition("Standard", 10, 0, false),
  new Ammunition("Armor Penetrating", 25, 0.25, false),
  new Ammunition("Piercing", 50, 0.5, true),
];


"Reinforced Wall"

I want to add tooltips to both unit types (Factory Units, Biter Units) & the ammunition, displaying all their stats.
Those should show up when hovering over the Unit Type in the Table or the Ammunition Type in the ammunition display.

The current updateUI Function:
function updateUI(factoryUnits, factorUnitCatalogue, biterUnits, ammunition, logs, battleStarted = false) {
  // Clear the tables
  factoryUnitsTable.innerHTML = "";
  biterUnitsTable.innerHTML = "";

  // Add headers to the tables
  const factoryHeader = document.createElement("tr");
  const biterHeader = document.createElement("tr");

  ["Type", "Health", "Count"].forEach((headerText) => {
    const factoryTh = document.createElement("th");
    const biterTh = document.createElement("th");
    factoryTh.innerText = headerText;
    biterTh.innerText = headerText;
    factoryHeader.appendChild(factoryTh);
    biterHeader.appendChild(biterTh);
  });

  if (!battleStarted) {
    const setupTh = document.createElement("th");
    setupTh.innerText = "Setup";
    setupTh.colSpan = 3;
    factoryHeader.appendChild(setupTh);
  }

  factoryUnitsTable.appendChild(factoryHeader);
  biterUnitsTable.appendChild(biterHeader);

  // Group the factory units
  const displayFactoryUnits = battleStarted ? Object.values(groupUnits(factoryUnits)) : factorUnitCatalogue;
  // console.log("factoryUnits:", factoryUnits);
  // console.log("displayFactoryUnits:", displayFactoryUnits);
  // Update the factory units table
  for (const unitData of displayFactoryUnits) {
    const row = document.createElement("tr");

    const nameCell = document.createElement("td");
    const unitName = unitData.name;
    nameCell.innerText = unitName;
    row.appendChild(nameCell);

    const healthCell = document.createElement("td");
    const progressBar = createHealthProgressBar(unitData.health, unitData.maxHealth);
    healthCell.appendChild(progressBar);
    row.appendChild(healthCell);

    const countCell = document.createElement("td");
    const unitCount = factoryUnits.filter((u) => u.name === unitName).length;
    countCell.innerText = unitCount;
    row.appendChild(countCell);
    startBattleButton.style.display = "none";
    //Pre Battle Setup
    if (!battleStarted) {
      startBattleButton.style.display = "";

      const buyArmyController = createQuantityInput(unitName, inputValues);

      const buyArmyControllerCell = document.createElement("td");
      buyArmyControllerCell.appendChild(buyArmyController);
      row.appendChild(buyArmyControllerCell);

      const buyCell = document.createElement("td");
      const buyButton = document.createElement("button");
      buyButton.innerText = "Add";
      buyButton.classList.add("buy-unit");
      buyButton.dataset.unitName = unitName;
      buyCell.appendChild(buyButton);
      row.appendChild(buyCell);

      const sellCell = document.createElement("td");
      const sellButton = document.createElement("button");
      sellButton.innerText = "Remove";
      sellButton.classList.add("sell-unit");
      sellButton.dataset.unitName = unitName;
      sellCell.appendChild(sellButton);
      row.appendChild(sellCell);
    }


    factoryUnitsTable.appendChild(row);
  }

  // Group the biter units
  const groupedBiterUnits = groupUnits(biterUnits);

  // Update the biter units table
  for (const [unitName, unitData] of Object.entries(groupedBiterUnits)) {
    const row = document.createElement("tr");

    const nameCell = document.createElement("td");
    nameCell.innerText = unitName;
    row.appendChild(nameCell);

    const healthCell = document.createElement("td");
    const progressBar = createHealthProgressBar(unitData.health, unitData.maxHealth);
    healthCell.appendChild(progressBar);
    row.appendChild(healthCell);

    const countCell = document.createElement("td");
    countCell.innerText = unitData.count;
    row.appendChild(countCell);

    biterUnitsTable.appendChild(row);
  }

  // Update the ammunition element
  updateAmmunitionDisplay(battleStarted);


  // // Update the battle log
  // logs.forEach((log) => {
  //   const logElement = document.createElement("li");
  //   logElement.innerText = log;
  //   battleLog.appendChild(logElement);
  // });

  // Pre Battle
  if (!battleStarted) {
    // Add event listeners to buy and sell buttons
    document.querySelectorAll(".buy-unit").forEach((button, index) => {
      button.addEventListener("click", (event) => {
        const unitName = event.target.dataset.unitName;
        const quantityInput = document.querySelectorAll(".unit-quantity")[index];
        const quantity = parseInt(quantityInput.value);
        inputValues[unitName] = quantity;
        buyFactoryUnit(unitName, factoryUnits, factorUnitCatalogue, quantity);
        updateUI(factoryUnits, factorUnitCatalogue, biterUnits, ammunition, logs, battleStarted, inputValues);
      });
    });

    document.querySelectorAll(".sell-unit").forEach((button, index) => {
      button.addEventListener("click", (event) => {
        const unitName = event.target.dataset.unitName;
        const quantityInput = document.querySelectorAll(".unit-quantity")[index];
        const quantity = parseInt(quantityInput.value);
        inputValues[unitName] = quantity;
        sellFactoryUnit(unitName, factoryUnits, quantity);
        updateUI(factoryUnits, factorUnitCatalogue, biterUnits, ammunition, logs, battleStarted, inputValues);
      });
    });

    // Calculate and display the total cost for the army
    displayArmyCost(factoryUnits);
  }
}

Some Context regarding Factory Units, Biter Units & Ammunition:
class FactoryUnit extends Unit {
  constructor(name, health, attack, armor, consumesAmmo, cost) {
    super(name, health, attack, armor);
    this.consumesAmmo = consumesAmmo;
    this.cost = cost;
    this.payedFor = false;
  }
}

// Initialize your factoryUnits and biterUnits here
const factorUnitCatalogue = [
  new FactoryUnit("Wall", 120, 0, 5, 0, { ironPlates: 5, bricks: 50 }),
  new FactoryUnit("Turret", 100, 30, 5, 1, { ironPlates: 150, gears: 50, copperCables: 50, bricks: 25 }),
  // ... additional factory unit types ...
];


class BiterUnit extends Unit {
  constructor(name, health, attack, armor, reward) {
    super(name, health, attack, armor);
    this.reward = reward;
  }
}

class Ammunition {
  constructor(name, damage, armorPenetration, piercing) {
    this.name = name;
    this.damage = damage;
    this.armorPenetration = armorPenetration;
    this.piercing = piercing;
  }
}

const ammunitionTypes = [
  new Ammunition("Melee", 0,0,false),
  new Ammunition("Standard", 10, 0, false),
  new Ammunition("Armor Penetrating", 25, 0.25, false),
  new Ammunition("Piercing", 50, 0.5, true),
];

Reference of how we do tooltips:
addTooltipToButtons(buttonClass, parcel) {
  const buttons = this.tableElement.querySelectorAll(buttonClass);
  buttons.forEach((button) => {
    // Show tooltip on mouseover for Buy buttons only
    if (buttonClass.includes("buy-building")) {
      button.addEventListener("mouseover", (event) => {
        const buildingId = event.target.dataset.buildingId;
        const building = buildingManager.getBuilding(buildingId);
        const costText = Object.entries(building.cost)
          .map(([resource, cost]) => `${cost} ${resource}`)
          .join("<br>");
        const buyText = `Cost:<br>${costText}`;

        tooltip.innerHTML = buyText;
        tooltip.style.display = "block";
        tooltip.style.left = event.pageX + 10 + "px";
        tooltip.style.top = event.pageY + 10 + "px";
      });

      // Hide tooltip on mouseout
      button.addEventListener("mouseout", () => {
        tooltip.style.display = "none";
      });

      // Update tooltip position on mousemove
      button.addEventListener("mousemove", (event) => {
        tooltip.style.left = event.pageX + 10 + "px";
        tooltip.style.top = event.pageY + 10 + "px";
      });
    }
  });
}



...createUnits("Small Biter", BiterUnit, smallBiterAmount, 80, 15, 5, {alienArtefacts: 0.005}),
...createUnits("Medium Biter", BiterUnit, mediumBiterAmount, 160, 25, 22, {alienArtefacts: 0.01}),
...createUnits("Big Biter", BiterUnit, bigBiterAmount, 320, 50, 38, {alienArtefacts: 0.032}),






I want to integrate rewards for winning a fight.
The rewards get calculated based on all defeated biters.
For this I want to add a new property to the BiterUnit class named "reward". This is an example reward:
rewards: {
    biterBody: 1,
    alienArtefacts: 0.1,
},

class BiterUnit extends Unit {}

The rewards should get added to the first parcel with a militaryHQ.



I want the Move PopUps Input field to look like the other input fields that we have in the game.

This is the Move PopUp. its in our HTML (& can stay there):
<!-- Move Popup -->
<div id="moveParcelOverlay" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.5); z-index: 1000; align-items: center; justify-content: center;">
    <div style="background: white; padding: 20px; border-radius: 5px;">
        <label for="parcelMoveInput">Move parcel:</label>
        <input type="number" id="parcelMoveInput" placeholder="Enter move amount">
        <button id="moveParcelButton">Move</button>
        <button id="closeMoveParcelOverlay">Cancel</button>
    </div>

These are the event listeners in parcelManipulation.js
// Move
document.getElementById('moveDropdownItem').addEventListener('click', () => {
    document.getElementById('moveParcelOverlay').style.display = 'flex';
});

document.getElementById('moveParcelButton').addEventListener('click', () => {
    parcelManipulation.moveParcel();
});

document.getElementById('closeMoveParcelOverlay').addEventListener('click', () => {
    document.getElementById('moveParcelOverlay').style.display = 'none';
});


This is an existing Input Field from another part of the code as context:
//Pre Battle Setup
if (!battleStarted) {
  const buyArmyController = createQuantityInput(unitName, inputValues);

  const buyArmyControllerCell = document.createElement("td");
  buyArmyControllerCell.appendChild(buyArmyController);
  row.appendChild(buyArmyControllerCell);

  const buyCell = document.createElement("td");
  const buyButton = document.createElement("button");
  buyButton.innerText = "Add";
  buyButton.classList.add("buy-unit");
  buyButton.dataset.unitName = unitName;
  buyCell.appendChild(buyButton);
  row.appendChild(buyCell);

  const sellCell = document.createElement("td");
  const sellButton = document.createElement("button");
  sellButton.innerText = "Remove";
  sellButton.classList.add("sell-unit");
  sellButton.dataset.unitName = unitName;
  sellCell.appendChild(sellButton);
  row.appendChild(sellCell);
}

Specific Function to create this input element:
function createQuantityInput(unitName, inputValues) {
  const buyArmyController = document.createElement("div");
  const minusBtn = document.createElement("div");
  const plusBtn = document.createElement("div");
  const quantityInput = document.createElement("input");

  // Set properties and attributes
  buyArmyController.className = "input-controller";

  minusBtn.className = "input-btn";
  minusBtn.innerText = "-";

  plusBtn.className = "input-btn";
  plusBtn.innerText = "+";

  quantityInput.type = "number";
  quantityInput.className = "input-display";

  quantityInput.value = inputValues[unitName] || 1;
  quantityInput.min = 1;
  quantityInput.classList.add("unit-quantity");

  // Append elements
  buyArmyController.append(minusBtn, quantityInput, plusBtn);

  // Function to handle button clicks
  const handleButtonClick = (increment) => {
    const currentVal = parseInt(quantityInput.value, 10) || 0;
    const newVal = currentVal + increment;

    if (newVal >= 1) {
      quantityInput.value = newVal;
    }
  };

  // Attach event listeners
  minusBtn.addEventListener("click", () => handleButtonClick(-1));
  plusBtn.addEventListener("click", () => handleButtonClick(1));

  return buyArmyController;
}



// Create input fields for forward and backward belts, also from other part of the code:
const beltTypes = ["forwardBelt", "backwardBelt"];
beltTypes.forEach((beltId, index) => {
  const beltController = this.createDirectionInput(beltId, resourceName);
  const beltUsage = this.parcel.beltUsage ? this.parcel.beltUsage[beltId] || 0 : 0;
  const beltCount = window.parcels.parcelList.reduce((sum, parcel) => sum + (parcel.buildings[beltId] || 0), 0);
  //const beltCount = this.parcel.buildings[beltId] * 2 || 0;

  const cell = this.createCell(beltController);
  cell.style.display = "none"; // Initially hide the Forward and Backward cells
  row.appendChild(cell);

  if (beltCount > 0) {
    const headerId = `${beltId === "forwardBelt" ? "forward" : "backward"}BeltHeader-${this.parcel.id}`;
    const headerElement = document.getElementById(headerId);
    headerElement.style.display = ""; // Unhide the header if the belt has been built

    const labelId = `${beltId === "forwardBelt" ? "forward" : "backward"}BeltHeader-${this.parcel.id}`;
    const labelElement = document.getElementById(labelId);
    labelElement.textContent = `${beltId === "forwardBelt" ? "Forwards" : "Backwards"} ${beltUsage}/${beltCount}`;

    cell.style.display = ""; // Unhide the cell if the belt has been built
  }
});



// Create overlay Snippet
const overlay = document.createElement("div");
const darkMode = localStorage.getItem('darkMode');

overlay.style.position = "absolute";
overlay.style.top = "0";
overlay.style.left = "0";
overlay.style.width = "100%";
overlay.style.height = "100%";

overlay.id = "battle-result-overlay";

if (darkMode === null || darkMode === 'true') {
  overlay.style.backgroundColor = "rgba(0, 2, 4, 0.8)";
  overlay.style.outline = "1px solid rgb(131, 122, 108)";
} else {
  overlay.style.backgroundColor = "rgba(255, 255, 255, 0.8)";
  overlay.style.outline = "1px solid";
}

//buyBuilding Function
function buyBuilding(parcel, buildingId) {
    const totalBuildings = Object.values(parcel.buildings).reduce((a, b) => a + b, 0);
    console.log("buyBuilding")
    if (totalBuildings < parcel.maxBuildings) {
        const building = buildingManager.getBuilding(buildingId);

        const resourceCost = Object.entries(building.cost);

        let canAfford = true;
        for (const [resourceName, cost] of resourceCost) {
            const totalResource = (parcel.resources[resourceName] || 0) + buildingManager.getResourcesFromRemoteConstructionFacilities(window.parcels.parcelList, resourceName);
            if (totalResource < cost) {
                canAfford = false;
                console.log(resourceName, totalResource - cost);
                break;
            }
        }

        if (canAfford) {
            if (parcel.buildings[buildingId] === undefined) {
                parcel.buildings[buildingId] = 0;
            }
            parcel.buildings[buildingId]++;

            for (const [resourceName, cost] of resourceCost) {
                if (parcel.resources[resourceName] >= cost) {
                    parcel.resources[resourceName] -= cost;
                } else {
                    const parcelResource = parcel.resources[resourceName] || 0;
                    const remainingResource = cost - parcelResource;
                    parcel.resources[resourceName] = 0;
                    buildingManager.deductResourcesFromRemoteConstructionFacilities(window.parcels.parcelList, resourceName, remainingResource);
                }
            }

            buildingManager.initializeResourceOutput(parcel, building);

            if (buildingId === "kiln" && !parcel.resources.coal) {
                parcel.resources = { coal: 0, ...parcel.resources };
            }

            if (buildingId === "ironSmelter" && !parcel.resources.ironOre) {
                parcel.resources = { ironOre: 0, ...parcel.resources };
            }

            updateBuildingDisplay(parcel);
        }
    }
}





const parcels = {
    parcelList: [],
    maxBuildingsPerParcel: 8,
    buyParcelCost: 2,

canBuyParcel(resourceCount) {
    return resourceCount >= this.buyParcelCost;
},

// Buy Parcel button event listener
buyParcelButton.addEventListener("click", () => {
    const highestParcelIndex = parcels.getParcelCount() - 1;
    const highestParcel = parcels.getParcel(highestParcelIndex);
    const highestParcelResource = highestParcel.resources.expansionPoints || 0;
    const resourceCount = highestParcelResource + buildingManager.getResourcesFromRemoteConstructionFacilities(window.parcels.parcelList, 'expansionPoints');

    if (parcels.canBuyParcel(resourceCount)) {
        const cost = parcels.buyParcelCost;

        if (highestParcel.resources.expansionPoints >= cost) {
            highestParcel.resources.expansionPoints -= cost;
        } else {
            const remainingCost = cost - highestParcelResource;
            highestParcel.resources.expansionPoints = 0;
            buildingManager.deductResourcesFromRemoteConstructionFacilities(window.parcels.parcelList, 'expansionPoints', remainingCost);
        }

        const newParcel = parcels.createNewParcel();
        ui.addParcelToUI(newParcel);
        ui.updateResourceDisplay(newParcel);

        // Select the newly bought parcel
        const newIndex = parcels.getParcelCount() - 1;
        ui.selectParcel(newIndex);
    }
});



I want to add a wave system that prepares the next biterUnits array.
The wave system generates the biter army based on a EvolutionFactor variable. This will be stored in the gameState object & for now is constant.

The evolution factor can be a number between 0 and 1.
There are three units that can be generated for now:
let biterUnits = [
  ...createUnits("Small Biter", BiterUnit, smallBiterAmount, 80, 5, 0),
  ...createUnits("Medium Biter", BiterUnit, mediumBiterAmount, 160, 10, 5),
  ...createUnits("Big Biter", BiterUnit, bigBiterAmount, 320, 25, 25),
];






Next I want to save & retrieve the relevant states for the fight system.
Here is what I am thinking. If you have better approaches, pleae let me know.
- We save the battle object in gameState.battle - this will be our anchor for saving as this should hold all relevant data
- When loading the game, we set the battle object itself to be updated





Next we will change how the Ammunition amount will be determined:
- There is a building with the id militaryHQ
- We will have a list of "AmmunitionTypeCatalogue" in which we define what ammunition types match to what resource id. Right now we only have "standardAmmunition" matching to the ammunition type "Standard".
context of existing ammunitionTypes:
const ammunitionTypes = [
  new Ammunition("Melee", 0,0,false),
  new Ammunition("Standard", 10, 0, false),
  new Ammunition("Armor Penetrating", 5, 0.5, false),
  new Ammunition("Piercing", 10, 0, true),
];

- To determine the available ammunition for a fight, we will count the total resources in all parcels that have a militaryHQ that match any of the ammunition types names
- During the fight we will deduct the consumed ammo from the parcels, much like we do in the remoteConstructionFacility logic
- Note that in this case, the active parcel will NOT count, only the ones that have the militaryHQ.

Here is a reference of how we count resources in parcels that have a remoteConstructionFacility, this should be very similar appraoch:
function startProject(project) {
    const selectedParcel = parcels.getParcel(ui.getSelectedParcelIndex());

    if (hasEnoughResources(selectedParcel, project.cost)) {
        for (const resource in project.cost) {
            const totalResource = (selectedParcel.resources[resource] || 0) + buildingManager.getResourcesFromRemoteConstructionFacilities(window.parcels.parcelList, resource);

            if (selectedParcel.resources[resource] >= project.cost[resource]) {
                selectedParcel.resources[resource] -= project.cost[resource];
            } else {
                const parcelResource = selectedParcel.resources[resource] || 0;
                const remainingResource = project.cost[resource] - parcelResource;
                selectedParcel.resources[resource] = 0;
                buildingManager.deductResourcesFromRemoteConstructionFacilities(window.parcels.parcelList, resource, remainingResource);
            }
        }

        for (const resource in project.reward) {
            if (!selectedParcel.resources[resource]) {
                selectedParcel.resources[resource] = 0;
            }
            selectedParcel.resources[resource] += project.reward[resource];
        }

        project.completed = true;
        // Remove the completed project and add the next project in the category (if any)
        projects[project.category].shift();

        // Hide the tooltip
        const tooltip = document.getElementById("tooltip");
        tooltip.style.display = "none";

        // Update the UI to reflect the changes
        ui.updateResourceDisplay(selectedParcel);
        //projectsContainer.innerHTML = ""; // Remove this line
        renderProjects();
    } else {
        alert("You don't have enough resources to start this project.");
    }
}




createDirectionInput(beltId, resourceName) {
  // Create elements
  const beltController = document.createElement("div");
  const minusBtn = document.createElement("div");
  const directionInput = document.createElement("input");
  const plusBtn = document.createElement("div");

  // Set properties and attributes
  beltController.className = "input-controller";

  minusBtn.className = "input-btn";
  minusBtn.innerText = "-";

  directionInput.type = "text";
  directionInput.className = "input-display";
  const inputValue = this.parcel.inputValues && this.parcel.inputValues[resourceName] && this.parcel.inputValues[resourceName][beltId] ? this.parcel.inputValues[resourceName][beltId] : 0;
  directionInput.value = inputValue;
  directionInput.dataset.belt = beltId;
  directionInput.dataset.resource = resourceName;
  directionInput.dataset.currentval = directionInput.value;

  plusBtn.className = "input-btn";
  plusBtn.innerText = "+";

  // Append elements
  beltController.append(minusBtn, directionInput, plusBtn);


I found the issue, when buying a new unit, we use this function:
function buyFactoryUnit(unitName, factoryUnits) {
  const unit = factoryUnits.find((u) => u.name === unitName);
  console.log("-unit-", unit);
  factoryUnits.push(new FactoryUnit(unit));
}

So we push the entire existing factory unit object into the first argument to create a new FactoryUnit, which is the name. So the unit construction here is invalid.

There is a deeper reason for this issue, so lets resolve this step by step.

The major issue is that to have factory units available to buy, we need to already add one of those factory units to the array like this:
const factoryUnits = [
  new FactoryUnit("Wall", 1500, 0, 0, 0, { ironPlates: 25, bricks: 20 }),
  new FactoryUnit("Turret", 100, 20, 3, 1, { ironPlates: 50, bricks: 40 }),
  // ... additional factory unit types ...
];

So I think we should have two arrays initialized. the factoryUnitsCatalogue which holds all possible units that can be bough.
This is the object that is used to create the rows of the table & is referenced for the buy button.
And then we have an empty factoryUnits array to begin with, as the total units bought will be 0.
This is also the array that we use to determine the "count" column in the factory-units table as this is the function we use for the active battle.





Right now we are initializing factory units with a set amount and we don't have costs attribute on them.

Lets set this up so that we initialize the factory units with cost & amount = 0 so that the buying & selling can set the amount. Costs should be like this:
cost: { ironPlates: 25, bricks: 20 },

I setup the structure as follows:
class Unit {
  constructor(name, health, attack, armor) {
    this.name = name;
    this.health = health;
    this.maxHealth = health;
    this.attack = attack;
    this.armor = armor;
  }

  dealDamage(damage) {
    this.health -= damage;
    return damage;
  }
}

class FactoryUnit extends Unit {
  constructor(name, health, attack, armor, consumesAmmo, cost) {
    super(name, health, attack, armor);
    this.consumesAmmo = consumesAmmo;
    this.cost = cost;
  }
}

  // Initialize your factoryUnits here
  const factoryUnits = [
    new FactoryUnit("Wall", FactoryUnit, 1500, 0, 0, 0, { ironPlates: 25, bricks: 20 }),
    new FactoryUnit("Turret", FactoryUnit, 100, 20, 3, 1, { ironPlates: 50, bricks: 40 }),
    // ... additional factory unit types ...
  ];

i am getting this error:
fightSystem.js:479 Uncaught TypeError: Cannot convert undefined or null to object
    at Function.entries (<anonymous>)
    at fightSystem.js:479:43

At this line:
for (const [resource, cost] of Object.entries(unit.cost)) {



Next up we need to update the UI so that the player can buy Units using existing resources.

1. Before the battle has started, the table needs to havee "buy" & "sell" buttons next to each unit that can be bought (see buy building buttons for reference)

<button data-building-id="${building.id}" class="buy-building-resource">Buy</button>
<button data-building-id="${building.id}" class="sell-building-resource">Sell</button>

2. Clicking "buy" adds one unit of that type to the factory army. Clicking sell works analogous.

3. Every factory unit has a cost attribute, much like this:
cost: { ironPlates: 25, bricks: 20 },

4. We calcluate the total cost for the army and display it in a table, one row for each resource

function startProject(project) {
    const selectedParcel = parcels.getParcel(ui.getSelectedParcelIndex());

    if (hasEnoughResources(selectedParcel, project.cost)) {
        for (const resource in project.cost) {
            const totalResource = (selectedParcel.resources[resource] || 0) + buildingManager.getResourcesFromRemoteConstructionFacilities(window.parcels.parcelList, resource);

            if (selectedParcel.resources[resource] >= project.cost[resource]) {
                selectedParcel.resources[resource] -= project.cost[resource];
            } else {
                const parcelResource = selectedParcel.resources[resource] || 0;
                const remainingResource = project.cost[resource] - parcelResource;
                selectedParcel.resources[resource] = 0;
                buildingManager.deductResourcesFromRemoteConstructionFacilities(window.parcels.parcelList, resource, remainingResource);
            }
        }

        for (const resource in project.reward) {
            if (!selectedParcel.resources[resource]) {
                selectedParcel.resources[resource] = 0;
            }
            selectedParcel.resources[resource] += project.reward[resource];
        }

        project.completed = true;
        // Remove the completed project and add the next project in the category (if any)
        projects[project.category].shift();

        // Hide the tooltip
        const tooltip = document.getElementById("tooltip");
        tooltip.style.display = "none";

        // Update the UI to reflect the changes
        ui.updateResourceDisplay(selectedParcel);
        //projectsContainer.innerHTML = ""; // Remove this line
        renderProjects();
    } else {
        alert("You don't have enough resources to start this project.");
    }
}




addTooltipToButtons(buttonClass, parcel) {
  const buttons = this.tableElement.querySelectorAll(buttonClass);
  buttons.forEach((button) => {
    // Show tooltip on mouseover for Buy buttons only
    if (buttonClass.includes("buy-building")) {
      button.addEventListener("mouseover", (event) => {
        const buildingId = event.target.dataset.buildingId;
        const building = buildingManager.getBuilding(buildingId);
        const costText = Object.entries(building.cost)
          .map(([resource, cost]) => `${cost} ${resource}`)
          .join("<br>");
        const buyText = `Cost:<br>${costText}`;

        tooltip.innerHTML = buyText;
        tooltip.style.display = "block";
        tooltip.style.left = event.pageX + 10 + "px";
        tooltip.style.top = event.pageY + 10 + "px";
      });

      // Hide tooltip on mouseout
      button.addEventListener("mouseout", () => {
        tooltip.style.display = "none";
      });

      // Update tooltip position on mousemove
      button.addEventListener("mousemove", (event) => {
        tooltip.style.left = event.pageX + 10 + "px";
        tooltip.style.top = event.pageY + 10 + "px";
      });
    }
  });
}

addResourceTooltips(parcel) {
  const resourceNames = this.tableElement.querySelectorAll(".resource-name");
  resourceNames.forEach((resourceName) => {
    resourceName.addEventListener("mouseover", (event) => {
      const resource = buildingManager.getBuildingByResourceName(event.target.textContent);
      const buildingCount = parcel.buildings[resource.id];
      const buildingCountChecked = buildingCount || 0;

      const inputText = Object.entries(resource.inputs || {})
      .map(([inputResource, amount]) => `${amount} ${inputResource}`)
      .join("<br>");
      const outputText = Object.entries(resource.outputs || {})
      .map(([outputResource, amount]) => `${amount} ${outputResource}`)
      .join("<br>");

      const totalInputText = Object.entries(resource.inputs || {})
      .map(([inputResource, amount]) => `${amount * buildingCountChecked} ${inputResource}`)
      .join("<br>");
      const totalOutputText = Object.entries(resource.outputs || {})
      .map(([outputResource, amount]) => `${amount * buildingCountChecked} ${outputResource}`)
      .join("<br>");

      const productionRateModifier = gameLoop.calculateProductionRateModifier(parcel, resource, buildingCount);
      const consumptionRateModifier = gameLoop.calculateConsumptionRateModifier(parcel, resource, buildingCount);

      const modifiedInputText = Object.entries(resource.inputs || {})
      .map(([inputResource, amount]) => `${(amount * (consumptionRateModifier)).toFixed(2)} ${inputResource}`)
      .join("<br>");
      const modifiedOutputText = Object.entries(resource.outputs || {})
      .map(([outputResource, amount]) => `${(amount * (productionRateModifier)).toFixed(2)} ${outputResource}`)
      .join("<br>");



      const totalModifiedInputText = Object.entries(resource.inputs || {})
      .map(([inputResource, amount]) => `${(amount * buildingCountChecked * (consumptionRateModifier)).toFixed(2)} ${inputResource}`)
      .join("<br>");
      const totalModifiedOutputText = Object.entries(resource.outputs || {})
      .map(([outputResource, amount]) => `${(amount * buildingCountChecked * (productionRateModifier)).toFixed(2)} ${outputResource}`)
      .join("<br>");

      const tooltipText = `
      <table>
      <tbody>

      <thead>
        <tr>
          <th colspan="2" style="text-align: left;"><b>Total (Modified)</b></th>
          <th></th>
          <th></th>
        </tr>
      </thead>
      <tr>
        <td>${totalModifiedInputText || "-"}</td>
        <td> &#x2192; </td>
        <td>${totalModifiedOutputText || "-"}</td>
      </tr>

        <thead>
          <tr>
            <th colspan="2" style="text-align: left;"><b>Modified</b></th>
            <th></th>
            <th></th>
          </tr>
        </thead>
        <tr>
          <td>${
            consumptionRateModifier !== undefined
              ? (consumptionRateModifier > 0 ? "+" : "") + Math.round((consumptionRateModifier-1) * 100) + "%"
              : ""
          }</td>
          <td></td>
          <td>${
            productionRateModifier !== undefined
              ? (productionRateModifier > 0 ? "+" : "") + Math.round((productionRateModifier-1) * 100) + "%"
              : ""
          }</td>
        </tr>
          <tr>
            <td>${modifiedInputText || "-"}</td>
            <td> &#x2192; </td>
            <td>${modifiedOutputText || "-"}</td>
          </tr>

          <thead>
            <tr>
              <th colspan="2" style="text-align: left;"><b>Total (Default)</b></th>
              <th></th>
              <th></th>
            </tr>
          </thead>
          <tr>
            <td>${totalInputText || "-"}</td>
            <td> &#x2192; </td>
            <td>${totalOutputText || "-"}</td>
          </tr>

          <thead>
            <tr>
              <th colspan="2" style="text-align: left;"><b>Default</b></th>
              <th></th>
              <th></th>
            </tr>
          </thead>
            <tr>
              <td>${inputText || "-"}</td>
              <td> &#x2192; </td>
              <td>${outputText || "-"}</td>
            </tr>
        </tbody>
      </table>`;

      tooltip.innerHTML = tooltipText;
      tooltip.style.display = "block";
      tooltip.style.left = event.pageX + 10 + "px";
      tooltip.style.top = event.pageY + 10 + "px";
    });

    resourceName.addEventListener("mouseout", () => {
      tooltip.style.display = "none";
    });

    resourceName.addEventListener("mousemove", (event) => {
      tooltip.style.left = event.pageX + 10 + "px";
      tooltip.style.top = event.pageY + 10 + "px";
    });
  });
}




To upgrade a parcel, we use this function:
parcels.upgradeParcel(parcel, "maxBuildingLimit")

If we want to upgrade from 3 to 5, we need to call this function two times







1. Provide a button or menu option to copy the selected parcel's configuration --> We have that:
                <button id="copyDropdownItem" class="menu-item">Copy</button>
                <button id="pasteDropdownItem" class="menu-item">Paste</button>

 2. What gets copied are
  - buildings (parcels.parcelList[copiedParcelIndex].buildings)
  - input values (parcels.parcelList[copiedParcelIndex].inputValues)

  3. To copy, we mark parcel as "copied", we use this as a pointer when pasting to see where we are pasting from. We can save that in the parcel object.

  4. When pasting, it should check if the target parcel can accommodate the buildings from the copied configuration (maxBuildings constraint).
      If it cannot, we have to calculate the cost to buy additional parcels.parcelList[target].upgrades.maxBuildingLimit to have enough space.
      We can find the information on which maxBuildingLimit upgrade gives how many building slots by looking inside the parcels object:
      const parcels = {
          parcelList: [],
          maxBuildingsPerParcel: 8,
          buyParcelCost: 2,
          upgradeCosts: {
            maxBuildingLimit: [
              {
                level: 1,
                cost: {
                  stone: 50,
                },
                maxBuildingLimit: 8,
              },
              {
                level: 2,
                cost: {
                  expansionPoints: 1,
                },
                maxBuildingLimit: 16,
              }, ... //rest of code

      If we need to buy additional upgrades, we should note the cost for these

    5. Besides the cost for possible building limit upgrades, we also need to calculate the cost for building the buildings themselves. To do this we
       - look at what buildings are already built and can stay
       - what buildings need to be sold
       - what buildings need to be bought
       and calculate the net cost based on that. Note that selling gives 100% of the resource cost back.

   6. Then, once we know the full cost for pasting, we evaluate if enough resources are present. Generally we look into the parcel that we paste to and, if the remoteConstructionFacility is present, in those parcels as well. For a better understanding of the buying rules, here is some code for context:
   function buyBuilding(parcel, buildingId) {
       const totalBuildings = Object.values(parcel.buildings).reduce((a, b) => a + b, 0);
       console.log("buyBuilding")
       if (totalBuildings < parcel.maxBuildings) {
           const building = buildingManager.getBuilding(buildingId);

           const resourceCost = Object.entries(building.cost);

           let canAfford = true;
           for (const [resourceName, cost] of resourceCost) {
               const totalResource = (parcel.resources[resourceName] || 0) + buildingManager.getResourcesFromRemoteConstructionFacilities(window.parcels.parcelList, resourceName);
               if (totalResource < cost) {
                   canAfford = false;
                   break;
               }
           }

           if (canAfford) {
               if (parcel.buildings[buildingId] === undefined) {
                   parcel.buildings[buildingId] = 0;
               }
               parcel.buildings[buildingId]++;

               for (const [resourceName, cost] of resourceCost) {
                   if (parcel.resources[resourceName] >= cost) {
                       parcel.resources[resourceName] -= cost;
                   } else {
                       const remainingResource = cost - parcel.resources[resourceName];
                       parcel.resources[resourceName] = 0;
                       buildingManager.deductResourcesFromRemoteConstructionFacilities(window.parcels.parcelList, resourceName, remainingResource);
                   }
               }

               buildingManager.initializeResourceOutput(parcel, building);

               if (buildingId === "kiln" && !parcel.resources.coal) {
                   parcel.resources = { coal: 0, ...parcel.resources };
               }

               if (buildingId === "ironSmelter" && !parcel.resources.ironOre) {
                   parcel.resources = { ironOre: 0, ...parcel.resources };
               }

               updateBuildingDisplay(parcel);
           }
       }
   }

   7. Once we determined if the paste is possible or not, we show in any case a pop-up where we can review the paste. if it's possible, the user can confirm or cancel. If it's not, the confirm button is disabled.
      We show the user the total cost of the project in a table like this:
      Resource | Amount Needed | Amount Stored | Amount Stored After
      Again, the "Amount Stored" might only be related to the target parcel, or include remoteConstructionFacility parcels resources as well if they are availbale.

   8. If the user clicks "confirm", the paste gets executed, the upgrades get bought, the buildings built, inputValues set and resource costs deducted as expected.
   9. We also paste customization information about the parcel, in this case that is name & color


10. Ensure that the UI updates properly when the copied configuration is pasted to the target parcel (resource and building displays).

Handle edge cases and invalid input gracefully, such as trying to paste when there's no copied configuration, pasting to a locked parcel, or pasting an invalid configuration.

Save and load the clipboard state (if necessary) to allow the user to copy and paste configurations across game sessions.
