createDirectionInput(beltId, resourceName) {
  // Create elements
  const beltController = document.createElement("div");
  const minusBtn = document.createElement("div");
  const directionInput = document.createElement("input");
  const plusBtn = document.createElement("div");

  // Set properties and attributes
  beltController.className = "input-controller";

  minusBtn.className = "input-btn";
  minusBtn.innerText = "-";

  directionInput.type = "text";
  directionInput.className = "input-display";
  const inputValue = this.parcel.inputValues && this.parcel.inputValues[resourceName] && this.parcel.inputValues[resourceName][beltId] ? this.parcel.inputValues[resourceName][beltId] : 0;
  directionInput.value = inputValue;
  directionInput.dataset.belt = beltId;
  directionInput.dataset.resource = resourceName;
  directionInput.dataset.currentval = directionInput.value;

  plusBtn.className = "input-btn";
  plusBtn.innerText = "+";

  // Append elements
  beltController.append(minusBtn, directionInput, plusBtn);


I found the issue, when buying a new unit, we use this function:
function buyFactoryUnit(unitName, factoryUnits) {
  const unit = factoryUnits.find((u) => u.name === unitName);
  console.log("-unit-", unit);
  factoryUnits.push(new FactoryUnit(unit));
}

So we push the entire existing factory unit object into the first argument to create a new FactoryUnit, which is the name. So the unit construction here is invalid.

There is a deeper reason for this issue, so lets resolve this step by step.

The major issue is that to have factory units available to buy, we need to already add one of those factory units to the array like this:
const factoryUnits = [
  new FactoryUnit("Wall", 1500, 0, 0, 0, { ironPlates: 25, bricks: 20 }),
  new FactoryUnit("Turret", 100, 20, 3, 1, { ironPlates: 50, bricks: 40 }),
  // ... additional factory unit types ...
];

So I think we should have two arrays initialized. the factoryUnitsCatalogue which holds all possible units that can be bough.
This is the object that is used to create the rows of the table & is referenced for the buy button.
And then we have an empty factoryUnits array to begin with, as the total units bought will be 0.
This is also the array that we use to determine the "count" column in the factory-units table as this is the function we use for the active battle.





Right now we are initializing factory units with a set amount and we don't have costs attribute on them.

Lets set this up so that we initialize the factory units with cost & amount = 0 so that the buying & selling can set the amount. Costs should be like this:
cost: { ironPlates: 25, bricks: 20 },

I setup the structure as follows:
class Unit {
  constructor(name, health, attack, armor) {
    this.name = name;
    this.health = health;
    this.maxHealth = health;
    this.attack = attack;
    this.armor = armor;
  }

  dealDamage(damage) {
    this.health -= damage;
    return damage;
  }
}

class FactoryUnit extends Unit {
  constructor(name, health, attack, armor, consumesAmmo, cost) {
    super(name, health, attack, armor);
    this.consumesAmmo = consumesAmmo;
    this.cost = cost;
  }
}

  // Initialize your factoryUnits here
  const factoryUnits = [
    new FactoryUnit("Wall", FactoryUnit, 1500, 0, 0, 0, { ironPlates: 25, bricks: 20 }),
    new FactoryUnit("Turret", FactoryUnit, 100, 20, 3, 1, { ironPlates: 50, bricks: 40 }),
    // ... additional factory unit types ...
  ];

i am getting this error:
fightSystem.js:479 Uncaught TypeError: Cannot convert undefined or null to object
    at Function.entries (<anonymous>)
    at fightSystem.js:479:43

At this line:
for (const [resource, cost] of Object.entries(unit.cost)) {



Next up we need to update the UI so that the player can buy Units using existing resources.

1. Before the battle has started, the table needs to havee "buy" & "sell" buttons next to each unit that can be bought (see buy building buttons for reference)

<button data-building-id="${building.id}" class="buy-building-resource">Buy</button>
<button data-building-id="${building.id}" class="sell-building-resource">Sell</button>

2. Clicking "buy" adds one unit of that type to the factory army. Clicking sell works analogous.

3. Every factory unit has a cost attribute, much like this:
cost: { ironPlates: 25, bricks: 20 },

4. We calcluate the total cost for the army and display it in a table, one row for each resource

function startProject(project) {
    const selectedParcel = parcels.getParcel(ui.getSelectedParcelIndex());

    if (hasEnoughResources(selectedParcel, project.cost)) {
        for (const resource in project.cost) {
            const totalResource = (selectedParcel.resources[resource] || 0) + buildingManager.getResourcesFromRemoteConstructionFacilities(window.parcels.parcelList, resource);

            if (selectedParcel.resources[resource] >= project.cost[resource]) {
                selectedParcel.resources[resource] -= project.cost[resource];
            } else {
                const parcelResource = selectedParcel.resources[resource] || 0;
                const remainingResource = project.cost[resource] - parcelResource;
                selectedParcel.resources[resource] = 0;
                buildingManager.deductResourcesFromRemoteConstructionFacilities(window.parcels.parcelList, resource, remainingResource);
            }
        }

        for (const resource in project.reward) {
            if (!selectedParcel.resources[resource]) {
                selectedParcel.resources[resource] = 0;
            }
            selectedParcel.resources[resource] += project.reward[resource];
        }

        project.completed = true;
        // Remove the completed project and add the next project in the category (if any)
        projects[project.category].shift();

        // Hide the tooltip
        const tooltip = document.getElementById("tooltip");
        tooltip.style.display = "none";

        // Update the UI to reflect the changes
        ui.updateResourceDisplay(selectedParcel);
        //projectsContainer.innerHTML = ""; // Remove this line
        renderProjects();
    } else {
        alert("You don't have enough resources to start this project.");
    }
}




addTooltipToButtons(buttonClass, parcel) {
  const buttons = this.tableElement.querySelectorAll(buttonClass);
  buttons.forEach((button) => {
    // Show tooltip on mouseover for Buy buttons only
    if (buttonClass.includes("buy-building")) {
      button.addEventListener("mouseover", (event) => {
        const buildingId = event.target.dataset.buildingId;
        const building = buildingManager.getBuilding(buildingId);
        const costText = Object.entries(building.cost)
          .map(([resource, cost]) => `${cost} ${resource}`)
          .join("<br>");
        const buyText = `Cost:<br>${costText}`;

        tooltip.innerHTML = buyText;
        tooltip.style.display = "block";
        tooltip.style.left = event.pageX + 10 + "px";
        tooltip.style.top = event.pageY + 10 + "px";
      });

      // Hide tooltip on mouseout
      button.addEventListener("mouseout", () => {
        tooltip.style.display = "none";
      });

      // Update tooltip position on mousemove
      button.addEventListener("mousemove", (event) => {
        tooltip.style.left = event.pageX + 10 + "px";
        tooltip.style.top = event.pageY + 10 + "px";
      });
    }
  });
}

addResourceTooltips(parcel) {
  const resourceNames = this.tableElement.querySelectorAll(".resource-name");
  resourceNames.forEach((resourceName) => {
    resourceName.addEventListener("mouseover", (event) => {
      const resource = buildingManager.getBuildingByResourceName(event.target.textContent);
      const buildingCount = parcel.buildings[resource.id];
      const buildingCountChecked = buildingCount || 0;

      const inputText = Object.entries(resource.inputs || {})
      .map(([inputResource, amount]) => `${amount} ${inputResource}`)
      .join("<br>");
      const outputText = Object.entries(resource.outputs || {})
      .map(([outputResource, amount]) => `${amount} ${outputResource}`)
      .join("<br>");

      const totalInputText = Object.entries(resource.inputs || {})
      .map(([inputResource, amount]) => `${amount * buildingCountChecked} ${inputResource}`)
      .join("<br>");
      const totalOutputText = Object.entries(resource.outputs || {})
      .map(([outputResource, amount]) => `${amount * buildingCountChecked} ${outputResource}`)
      .join("<br>");

      const productionRateModifier = gameLoop.calculateProductionRateModifier(parcel, resource, buildingCount);
      const consumptionRateModifier = gameLoop.calculateConsumptionRateModifier(parcel, resource, buildingCount);

      const modifiedInputText = Object.entries(resource.inputs || {})
      .map(([inputResource, amount]) => `${(amount * (consumptionRateModifier)).toFixed(2)} ${inputResource}`)
      .join("<br>");
      const modifiedOutputText = Object.entries(resource.outputs || {})
      .map(([outputResource, amount]) => `${(amount * (productionRateModifier)).toFixed(2)} ${outputResource}`)
      .join("<br>");



      const totalModifiedInputText = Object.entries(resource.inputs || {})
      .map(([inputResource, amount]) => `${(amount * buildingCountChecked * (consumptionRateModifier)).toFixed(2)} ${inputResource}`)
      .join("<br>");
      const totalModifiedOutputText = Object.entries(resource.outputs || {})
      .map(([outputResource, amount]) => `${(amount * buildingCountChecked * (productionRateModifier)).toFixed(2)} ${outputResource}`)
      .join("<br>");

      const tooltipText = `
      <table>
      <tbody>

      <thead>
        <tr>
          <th colspan="2" style="text-align: left;"><b>Total (Modified)</b></th>
          <th></th>
          <th></th>
        </tr>
      </thead>
      <tr>
        <td>${totalModifiedInputText || "-"}</td>
        <td> &#x2192; </td>
        <td>${totalModifiedOutputText || "-"}</td>
      </tr>

        <thead>
          <tr>
            <th colspan="2" style="text-align: left;"><b>Modified</b></th>
            <th></th>
            <th></th>
          </tr>
        </thead>
        <tr>
          <td>${
            consumptionRateModifier !== undefined
              ? (consumptionRateModifier > 0 ? "+" : "") + Math.round((consumptionRateModifier-1) * 100) + "%"
              : ""
          }</td>
          <td></td>
          <td>${
            productionRateModifier !== undefined
              ? (productionRateModifier > 0 ? "+" : "") + Math.round((productionRateModifier-1) * 100) + "%"
              : ""
          }</td>
        </tr>
          <tr>
            <td>${modifiedInputText || "-"}</td>
            <td> &#x2192; </td>
            <td>${modifiedOutputText || "-"}</td>
          </tr>

          <thead>
            <tr>
              <th colspan="2" style="text-align: left;"><b>Total (Default)</b></th>
              <th></th>
              <th></th>
            </tr>
          </thead>
          <tr>
            <td>${totalInputText || "-"}</td>
            <td> &#x2192; </td>
            <td>${totalOutputText || "-"}</td>
          </tr>

          <thead>
            <tr>
              <th colspan="2" style="text-align: left;"><b>Default</b></th>
              <th></th>
              <th></th>
            </tr>
          </thead>
            <tr>
              <td>${inputText || "-"}</td>
              <td> &#x2192; </td>
              <td>${outputText || "-"}</td>
            </tr>
        </tbody>
      </table>`;

      tooltip.innerHTML = tooltipText;
      tooltip.style.display = "block";
      tooltip.style.left = event.pageX + 10 + "px";
      tooltip.style.top = event.pageY + 10 + "px";
    });

    resourceName.addEventListener("mouseout", () => {
      tooltip.style.display = "none";
    });

    resourceName.addEventListener("mousemove", (event) => {
      tooltip.style.left = event.pageX + 10 + "px";
      tooltip.style.top = event.pageY + 10 + "px";
    });
  });
}




To upgrade a parcel, we use this function:
parcels.upgradeParcel(parcel, "maxBuildingLimit")

If we want to upgrade from 3 to 5, we need to call this function two times







1. Provide a button or menu option to copy the selected parcel's configuration --> We have that:
                <button id="copyDropdownItem" class="menu-item">Copy</button>
                <button id="pasteDropdownItem" class="menu-item">Paste</button>

 2. What gets copied are
  - buildings (parcels.parcelList[copiedParcelIndex].buildings)
  - input values (parcels.parcelList[copiedParcelIndex].inputValues)

  3. To copy, we mark parcel as "copied", we use this as a pointer when pasting to see where we are pasting from. We can save that in the parcel object.

  4. When pasting, it should check if the target parcel can accommodate the buildings from the copied configuration (maxBuildings constraint).
      If it cannot, we have to calculate the cost to buy additional parcels.parcelList[target].upgrades.maxBuildingLimit to have enough space.
      We can find the information on which maxBuildingLimit upgrade gives how many building slots by looking inside the parcels object:
      const parcels = {
          parcelList: [],
          maxBuildingsPerParcel: 8,
          buyParcelCost: 2,
          upgradeCosts: {
            maxBuildingLimit: [
              {
                level: 1,
                cost: {
                  stone: 50,
                },
                maxBuildingLimit: 8,
              },
              {
                level: 2,
                cost: {
                  expansionPoints: 1,
                },
                maxBuildingLimit: 16,
              }, ... //rest of code

      If we need to buy additional upgrades, we should note the cost for these

    5. Besides the cost for possible building limit upgrades, we also need to calculate the cost for building the buildings themselves. To do this we
       - look at what buildings are already built and can stay
       - what buildings need to be sold
       - what buildings need to be bought
       and calculate the net cost based on that. Note that selling gives 100% of the resource cost back.

   6. Then, once we know the full cost for pasting, we evaluate if enough resources are present. Generally we look into the parcel that we paste to and, if the remoteConstructionFacility is present, in those parcels as well. For a better understanding of the buying rules, here is some code for context:
   function buyBuilding(parcel, buildingId) {
       const totalBuildings = Object.values(parcel.buildings).reduce((a, b) => a + b, 0);
       console.log("buyBuilding")
       if (totalBuildings < parcel.maxBuildings) {
           const building = buildingManager.getBuilding(buildingId);

           const resourceCost = Object.entries(building.cost);

           let canAfford = true;
           for (const [resourceName, cost] of resourceCost) {
               const totalResource = (parcel.resources[resourceName] || 0) + buildingManager.getResourcesFromRemoteConstructionFacilities(window.parcels.parcelList, resourceName);
               if (totalResource < cost) {
                   canAfford = false;
                   break;
               }
           }

           if (canAfford) {
               if (parcel.buildings[buildingId] === undefined) {
                   parcel.buildings[buildingId] = 0;
               }
               parcel.buildings[buildingId]++;

               for (const [resourceName, cost] of resourceCost) {
                   if (parcel.resources[resourceName] >= cost) {
                       parcel.resources[resourceName] -= cost;
                   } else {
                       const remainingResource = cost - parcel.resources[resourceName];
                       parcel.resources[resourceName] = 0;
                       buildingManager.deductResourcesFromRemoteConstructionFacilities(window.parcels.parcelList, resourceName, remainingResource);
                   }
               }

               buildingManager.initializeResourceOutput(parcel, building);

               if (buildingId === "kiln" && !parcel.resources.coal) {
                   parcel.resources = { coal: 0, ...parcel.resources };
               }

               if (buildingId === "ironSmelter" && !parcel.resources.ironOre) {
                   parcel.resources = { ironOre: 0, ...parcel.resources };
               }

               updateBuildingDisplay(parcel);
           }
       }
   }

   7. Once we determined if the paste is possible or not, we show in any case a pop-up where we can review the paste. if it's possible, the user can confirm or cancel. If it's not, the confirm button is disabled.
      We show the user the total cost of the project in a table like this:
      Resource | Amount Needed | Amount Stored | Amount Stored After
      Again, the "Amount Stored" might only be related to the target parcel, or include remoteConstructionFacility parcels resources as well if they are availbale.

   8. If the user clicks "confirm", the paste gets executed, the upgrades get bought, the buildings built, inputValues set and resource costs deducted as expected.
   9. We also paste customization information about the parcel, in this case that is name & color


10. Ensure that the UI updates properly when the copied configuration is pasted to the target parcel (resource and building displays).

Handle edge cases and invalid input gracefully, such as trying to paste when there's no copied configuration, pasting to a locked parcel, or pasting an invalid configuration.

Save and load the clipboard state (if necessary) to allow the user to copy and paste configurations across game sessions.
